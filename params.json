{"name":"Driver reverse","tagline":"","body":"#驱动的逆向分析\r\n\r\n##背景\r\n近日得到一样本，主要行为是修改浏览器主页，被修改的浏览器主页无法改回，十分好奇是通过什么手段来修改的，也当作是对驱动分析的一次练手。\r\n\r\n样本信息：\r\n\r\n    样本名称：dffim.exe\r\n\t样本大小：955,392 字节\r\n\t样本MD5：8f6d7b4a888426a416c3eecf43e76ad0\r\n\r\n##文件释放\r\n\r\n样本运行后会释放三个驱动文件`dmvsc2.sys`、`HDAudBus2.sys`、`usbehci2.sys`，并对其进行解密，还会释放一个`DLL`，该文件是用来进行驱动加载的。样本会将三个驱动文件进行安装，然后退出。修改浏览器主页的行为是由驱动文件`dmvsc2.sys`来完成的，下面主要对该文件进行分析。\r\n\r\n##dmvsc2.sys分析\r\n\r\n我采用的方法是：`IDA`静态分析+`WinDbg`动态调试。\r\n\r\n###驱动调试\r\n\r\n对于驱动的动态调试，采用双机调试，至于怎么搭建环境，请google一下吧。\r\n\r\n虚拟机内，`OD`加载`dffim.exe`，执行到驱动安装的位置\r\n\r\n\t00401E5B   .  FFD7          call edi                                 ;  zyinstal.ZY_INS\r\n\t00401E5D   .  8D9424 600600>lea edx,dword ptr ss:[esp+0x660]\r\n\t00401E64   .  52            push edx\r\n\t00401E65   .  8D8424 840E00>lea eax,dword ptr ss:[esp+0xE84]\r\n\r\n使用`WinDbg`断下，在`WinDbg`内下模块加载断点`sxe ld:dmvsc2`（这里要注意，一定不能加后缀。）再输入命令`g`，恢复虚拟机的执行。在`OD`中，执行驱动安装。这时，`WinDbg`中会断下，使用命令`lm`查看模块的基地址，在`IDA`中调用`Edit->Segements->Rebase program`重置基地址，这样可以保证`IDA`与`WinDbg`的地址是一致的，方便后面的分析。\r\n\r\n    kd> dt _image_dos_header b223c000\r\n\tnt!_IMAGE_DOS_HEADER\r\n\t   .\r\n       .\r\n       .\r\n\t   +0x03c e_lfanew         : 0n224\r\n\tkd> dt -r2 _image_nt_headers b223c000+0n224\r\n\tnt!_IMAGE_NT_HEADERS\r\n          .\r\n          .\r\n          .\r\n\t      +0x010 AddressOfEntryPoint : 0x2334\r\n          .\r\n          .\r\n          .\r\n\r\n`0xb223c000`是我的基地址，每次加载会不同。通过上面两条命令，可以找到驱动程序`DriverEntry`的地址，在此处下`bp`断点，就可以开始驱动程序的调试。\r\n\r\n###驱动功能\r\n\r\n1. 注册进程回调函数\r\n2. 注册映像加载回调函数\r\n3. 创建内核线程执行操作（与主题无关，未分析）\r\n4. 创建内核线程删除执行删除注册表（略过）\r\n5. 遍历分区，获取信息（与主题无关，未分析）\r\n6. 检查文件系统`\\\\FileSystem\\\\NTFS`（与主题无关，未分析）\r\n\r\n###进程回调函数\r\n\r\n####基础\r\n\r\n进程回调函数使用`PsSetCreateProcessNotifyRoutine`创建，函数原型如下：\r\n\r\n\tNTSTATUS PsSetCreateProcessNotifyRoutine( \r\n\tIN PCREATE_PROCESS_NOTIFY_ROUTINE NotifyRoutine, \r\n\tIN BOOLEAN Remove \r\n\t);\r\n\r\n`NotifyRoutine`为注册的回调函数地址，`Remove`为`TRUE`表示创建回调函数，为`FALSE`表示取消回调函数。\r\n\r\n回调函数原型如下：\r\n\r\n\tVOID (*PCREATE_PROCESS_NOTIFY_ROUTINE) ( \r\n\tIN HANDLE ParentId, \r\n\tIN HANDLE ProcessId, \r\n\tIN BOOLEAN Create \r\n\t); \r\n\r\n其中，`ParentId`是父进程ID，`ProcessId`为进程ID，而`Create`表示进程创建或是退出，`TRUE`表示创建进程，`FALSE`表示结束进程。每当进程创建或结束时，就会触发该回调函数。\r\n\r\n####本次回调函数行为\r\n\r\n下面说一下`dmvsc2.sys`中回调函数的作用，通过`ZwQueryInformationProcess`获取当前进程的名称，计算进程的`CRC32`，判断是否为样本所关注的进程，若是，则修改主页。所关注的进程`CRC32`列表以链表的形式保存在内存中，在创建回调函数之前，进行初始化填充。下面的我提取出的列表，随便计算了几个浏览器的进程名，全部在该列表中。\r\n\r\n\tCRC      进程名\r\n\t74fc6984\r\n\t0922df04 IEXPLORE.EXE\r\n\tbdeab0eb 360SE.EXE\r\n\t4d7c371d 360CHROME.EXE\r\n\te0dcda05\r\n\t4467ba9c\r\n\tdf87d85f BAIDUBROWSER.EXE\r\n\t81762398\r\n\te9f3dc6f\r\n\tc84f40f0 CHROME.EXE\r\n\t662d9d39 FIREFOX.EXE\r\n\t04e48e16 LIEBAO.EXE\r\n\tcc7bf8dd MAXTHON.EXE\r\n\t60309c56 \r\n\ta3578083 QQBROWSER.EXE\r\n\t11aa3d47\r\n\tdcfc6e80\r\n\t2daddb99 SOGOUEXPLORER.EXE\r\n\t12116378\r\n\t6a0aa936\r\n\t83cd9976\r\n\r\n注：`CRC32`的计算`hex((-1 - binascii.crc32('360SE.EXE')) & 0xffffffff)`\r\n\r\n对这些进程的后续操作，目前并未分析透彻。初步判断，在该部分中并未修改浏览器主页。\r\n\r\n###映像加载回调函数\r\n\r\n####基础\r\n\r\n映像加载回调函数使用函数`PsSetLoadImageNotifyRoutine`创建，函数原型如下：\r\n\r\n\tNTSTATUS PsSetLoadImageNotifyRoutine(\r\n\t  _In_ PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine\r\n\t);\r\n\r\n`NotifyRoutine`为回调函数地址，回调函数原型如下：\r\n\r\n\tVOID (*PLOAD_IMAGE_NOTIFY_ROUTINE)(\r\n\t    __in_opt PUNICODE_STRING  FullImageName,\r\n\t    __in HANDLE  ProcessId,\r\n\t    __in PIMAGE_INFO  ImageInfo\r\n\t    );\r\n\r\n`FullImageName`为完整映像名，`ProcessId`为进程ID，`ImageInfo`为映像指针。当驱动映像或用户映像（如：DLL或EXE)映射到虚拟内存时，会触发该回调函数，它的执行在映像映射到虚拟内存之后，未执行之前。\r\n\r\n####本次回调函数行为\r\n\r\n下面看一下`dmvsc2.sys`中映像回调函数都做了什么。\r\n\r\n- 获取模块`ntdll`中的三个函数地址`LdrLoadDll`，`LdrGetProcedureAddress`，`NtProtectVirtualMemory`\r\n\r\n\t\tif ( !k_strcmp((int)FullImageName, &s_ntdll) )// 不相等，则走LABEL_17\r\n\t      goto LABEL_17;\r\n\t    v7 = (const void *)(v4 + 104);\r\n\t    m_GetFuncAddress((int)ImageInfo->ImageBase, v4 + 104);// 获取三个函数的地址：\r\n\t                                                // LdrLoadDll\r\n\t                                                // LdrGetProcedureAddress\r\n\t                                                // NtProtectVirtualMemory\r\n- 创建`Section`，并映射到内存\r\n\r\n\t\tif ( ZwCreateSection(&SectionHandle, 0xF001Fu, &ObjectAttributes, &MaximumSize, 0x40u, 0x8000000u, 0) >= 0\r\n\t\t  && ZwMapViewOfSection(\r\n\t\t       SectionHandle,\r\n\t\t       (HANDLE)0xFFFFFFFF,\r\n\t\t       &BaseAddress,\r\n\t\t       0,\r\n\t\t       MaximumSize.LowPart,\r\n\t\t       &SectionOffset,\r\n\t\t       &ViewSize,\r\n\t\t       ViewUnmap,\r\n\t\t       0,\r\n\t\t       0x40u) >= 0 )\r\n\t\t  memset(BaseAddress, 0, MaximumSize.LowPart);\r\n\t\tif ( SectionHandle )\r\n\t\t  ZwClose(SectionHandle);\r\n\t\treturn BaseAddress;\r\n\r\n- 将函数`0xB2331AFE`（此时基地址为：`0xB232F000`）复制到创建到的`Section`中\r\n\r\n\t\tqmemcpy((char *)v6 + v4 + 40, sub_B2331AFE, 0x800u);// ///////\r\n\r\n- 此时，对函数`0xB2331AFE`下断点，运行起来，会发现程序断下了，但位置却不是`0xB2331AFE`。原因是当下断点时，会把该函数第一个字节改为`CC`，后面当把这个函数复制到上面创建的`Section`时，断点也一起被复制过去了。在这里看到与之前的有所不同，前面的地址是：`001b:00157028`，`001b`是CS段的地址，CS段最后两位表示当前进程的权限级别，即CPL，`001b`的二进制为`0001 1011`，最低两位为`11`，表示现在进程是运行于`Ring3`状态下。\r\n\r\n\t\tkd> g\r\n\t\tBreak instruction exception - code 80000003 (first chance)\r\n\t\t001b:00157028 cc              int     3\r\n\r\n- 使用`eb`指令，将首字节的`CC`改为原来的`8B`，在此段代码中，会调用之前获取的三个函数`LdrLoadDll`，`LdrGetProcedureAddress`，`NtProtectVirtualMemory`，找到这三处代码调用的地方，下断点，如下：\r\n\r\n\t\t001b:001570ce ff17            call    dword ptr [edi]   //LdrLoadDll\r\n\t\t001b:00157152 ff5708          call    dword ptr [edi+8]  //LdrGetProcedureAddress\r\n\t\t001b:001571bb ff5710          call    dword ptr [edi+10h]  //NtProtectVirtualMemory\r\n\r\n- 还有一处需要注意的地方，当模块加载完成，函数地址获取完，权限设置好之后，会跳到新的地址处执行\r\n\r\n\t\t001b:0015724a ffd0            call    eax\r\n\r\n- 将上面几个地方设置断点，就可以运行分析了。这里有一个技巧，因为这部分需要获取的函数地址太多，可以只记录加载的每个模块的基地址，再结合最后获取到的地址，通过IDA加载相关的DLL来判断该函数是什么。\r\n- `Kernel32.dll`基地址：`7c800000`，函数地址保存位置：`0014b000`\r\n- `User32.dll`基地址：`77d10000`，函数地址保存位置：`0014b170`\r\n- `SHELL32.dll`基地址：`7d590000`，函数地址保存位置：`0014b15c`\r\n- `SHLWAPI.dll`基地址：`77f40000`，函数地址保存位置：`0014b168`\r\n- `PSAPI.dll`基地址：`76bc0000`，函数地址保存位置：`0014b154`\r\n\r\n下面是通过`IDA`获取的该模块可能会使用到的函数地址及名称。\r\n\r\n\t\t0014b000  7c809b74 VirtualFree\r\n\t\t0014b004  7c80f9ed GetPrivateProfileStringW\r\n\t\t0014b008  7c810e17 WriteFile\r\n\t\t0014b00c  7c8309d1 OpenProcess\r\n\t\t0014b010  7c802446 Sleep\r\n\t\t0014b014  7c80b465 GetModuleFileNameW\r\n\t\t0014b018  7c8107f0 CreateFileW\r\n\t\t0014b01c  7c832748 GetPrivateProfileIntW\r\n\t\t0014b020  7c80ae30 GetProcAddress\r\n\t\t0014b024  7c809ae1 VirtualAlloc\r\n\t\t0014b028  7c83019f GetDiskFreeSpaceW\r\n\t\t0014b02c  7c80a864 GetLocalTime\r\n\t\t0014b030  7c80997b GetCurrentThread\r\n\t\t0014b034  7c801629 DeviceIoControl\r\n\t\t0014b038  7c80b731 GetModuleHandleA\r\n\t\t0014b03c  7c809bd7 CloseHandle\r\n\t\t0014b040  7c8099b0 GetCurrentProcessId\r\n\t\t0014b044  7c8106c7 CreateThread\r\n\t\t0014b048  7c92fe01 ntdll!RtlGetLastWin32Error\r\n\t\t0014b04c  7c80cd38 LCMapStringW\r\n\t\t0014b050  7c838e00 LCMapStringA\r\n\t\t0014b054  7c85b335 OutputDebugStringW\r\n\t\t0014b058  7c8323ea CreateDirectoryW\r\n\t\t0014b05c  7c802336 CreateProcessW\r\n\t\t0014b060  7c810b07 GetFileSize\r\n\t\t0014b064  7c81cafa ExitProcess\r\n\t\t0014b068  7c80a520 GetStringTypeW\r\n\t\t0014b06c  7c809c88 MultiByteToWideChar\r\n\t\t0014b070  7c838a24 GetStringTypeA\r\n\t\t0014b074  7c80d2f2 GetLocaleInfoA\r\n\t\t0014b078  7c81115b IsValidCodePage\r\n\t\t0014b07c  7c812837 GetOEMCP\r\n\t\t0014b080  7c8099a5 GetACP\r\n\t\t0014b084  7c812f06 GetCPInfo\r\n\t\t0014b088  7c9304bd ntdll!RtlSizeHeap\r\n\t\t0014b08c  7c80b8b9 InitializeCriticalSectionAndSpinCount\r\n\t\t0014b090  7c8017e9 GetSystemTimeAsFileTime\r\n\t\t0014b094  7c80932e GetTickCount\r\n\t\t0014b098  7c80a4b7 QueryPerformanceCounter\r\n\t\t0014b09c  7c812f98 GetEnvironmentStringsW\r\n\t\t0014b0a0  7c80ac6e FreeLibrary\r\n\t\t0014b0a4  7c801d7b LoadLibraryA\r\n\t\t0014b0a8  7c80de85 GetCurrentProcess\r\n\t\t0014b0ac  7c80ba61 VirtualQuery\r\n\t\t0014b0b0  7c92fe10 ntdll!RtlRestoreLastWin32Error\r\n\t\t0014b0b4  7c801ad4 VirtualProtect\r\n\t\t0014b0b8  7c809832 InterlockedCompareExchange\r\n\t\t0014b0bc  7c8097b8 GetCurrentThreadId\r\n\t\t0014b0c0  7c83290f ResumeThread\r\n\t\t0014b0c4  7c8355d4 FlushInstructionCache\r\n\t\t0014b0c8  7c839725 GetThreadContext\r\n\t\t0014b0cc  7c863aa9 SetThreadContext\r\n\t\t0014b0d0  7c83974a SuspendThread\r\n\t\t0014b0d4  7c92ff0d ntdll!RtlFreeHeap\r\n\t\t0014b0d8  7c9300a4 ntdll!RtlAllocateHeap\r\n\t\t0014b0dc  7c812fad GetCommandLineA\r\n\t\t0014b0e0  7c812a99 RaiseException\r\n\t\t0014b0e4  7c94aba5 ntdll!RtlUnwind\r\n\t\t0014b0e8  7c801e1a TerminateProcess\r\n\t\t0014b0ec  7c863e6a UnhandledExceptionFilter\r\n\t\t0014b0f0  7c8449fd SetUnhandledExceptionFilter\r\n\t\t0014b0f4  7c813123 IsDebuggerPresent\r\n\t\t0014b0f8  7c812c46 HeapCreate\r\n\t\t0014b0fc  7c810f88 HeapDestroy\r\n\t\t0014b100  7c93135a ntdll!RtlDeleteCriticalSection\r\n\t\t0014b104  7c9210e0 ntdll!RtlLeaveCriticalSection\r\n\t\t0014b108  7c921000 ntdll!RtlEnterCriticalSection\r\n\t\t0014b10c  7c939b80 ntdll!RtlReAllocateHeap\r\n\t\t0014b110  7c80e4cd GetModuleHandleW\r\n\t\t0014b114  7c812fc9 GetStdHandle\r\n\t\t0014b118  7c80b55f GetModuleFileNameA\r\n\t\t0014b11c  7c8097d0 TlsGetValue\r\n\t\t0014b120  7c812e2f TlsAlloc\r\n\t\t0014b124  7c809c55 TlsSetValue\r\n\t\t0014b128  7c813767 TlsFree\r\n\t\t0014b12c  7c8097f6 InterlockedIncrement\r\n\t\t0014b130  7c80980a InterlockedDecrement\r\n\t\t0014b134  7c80cd27 LockResource\r\n\t\t0014b138  7c810ee1 GetFileType\r\n\t\t0014b13c  7c801ef2 GetStartupInfoA\r\n\t\t0014b140  7c81d6d7 FreeEnvironmentStringsA\r\n\t\t0014b144  7c81cc7b GetEnvironmentStrings\r\n\t\t0014b148  7c814b77 FreeEnvironmentStringsW\r\n\t\t0014b14c  7c80a164 WideCharToMultiByte\r\n\t\t0014b150  00000000\r\n\t\t0014b154  76bc3d2f GetProcessImageFileNameW\r\n\t\t0014b158  00000000\r\n\t\t0014b15c  7d685bf0 ShellExecuteW\r\n\t\t0014b160  7d5bed76 SHGetFolderPathW\r\n\t\t0014b164  00000000\r\n\t\t0014b168  77f47d89 PathFileExistsW\r\n\t\t0014b16c  00000000\r\n\t\t0014b170  77d2c9c3 FindWindowW\r\n\t\t0014b174  77d2929a SendMessageW\r\n\t\t0014b178  77d1e0e3 FindWindowExW\r\n\t\t0014b17c  00000000\r\n\t\t0014b180  00000000\r\n\r\n该回调函数通过`call eax`直接跳转到核心的DLL模块中运行，这部分的分析至此结束，下面我们再开始对核心的DLL模块进行分析。\r\n\r\n###核心DLL的分析\r\n\r\n从`WinDbg`中提取出来核心DLL，修复一下文件头，使用`IDA`进行分析，该模块分析起来难度不大，会读取配置文件`config_temp.ini`。\r\n\r\n- 内部含有两个`URL`，均为硬编码，进行了简单的加密，根据配置文件的信息来决定使用哪个`URL`，解密后的`URL`\r\n\r\n\t\thttp://www.i1236.com/?tni=9431472574_hao\r\n\t\thttp://www.hao123.com/?tn=93375910_hao_pg\r\n\r\n- 解密脚本\r\n\r\n\t\t>>> s = '!jwxu@67xyz2mgv9351gts6Gup@=89>=:33cmgvgqi'\r\n\t\t>>> o = ''\r\n\t\t>>> for i in xrange(len(s)):\r\n\t\t...     o += chr(ord(s[i])-1-(i%8))\r\n\t\t...\r\n\t\t>>> o\r\n\r\n- 修改浏览器主页方法有两种，针对不同的浏览器，使用不同的方法\r\n\r\n  - 使用`CreateProcessW`来创建带参数的浏览器窗口，参数如下：`C:\\Program Files\\Internet Explorer\\iexplore.exe\" http://www.i1236.com/?tni=9431472574_hao`，该方法针对下面的浏览器。\r\n  \r\n\t          if ( m_strcmp(lp_ImageName, (int)L\"*\\\\iexplore.exe*\")\r\n\t            || m_strcmp(lp_ImageName, (int)L\"*\\\\360se.exe*\")\r\n\t            || m_strcmp(lp_ImageName, (int)L\"*\\\\360chrome.exe*\")\r\n\t            || m_strcmp(lp_ImageName, (int)L\"*\\\\baidubrowser.exe*\")\r\n\t            || m_strcmp(lp_ImageName, (int)L\"*\\\\hao123browser.exe*\")\r\n\t            || m_strcmp(lp_ImageName, (int)L\"*\\\\Juzi.exe*\")\r\n\t            || m_strcmp(lp_ImageName, (int)L\"*\\\\chrome.exe*\")\r\n\t            || m_strcmp(lp_ImageName, (int)L\"*\\\\liebao.exe*\")\r\n\t            || m_strcmp(lp_ImageName, (int)L\"*\\\\launcher.exe*\")\r\n\t            || m_strcmp(lp_ImageName, (int)L\"*\\\\Safari.exe*\")\r\n\t            || m_strcmp(lp_ImageName, (int)L\"*\\\\2345Explorer.exe*\")\r\n\t            || m_strcmp(lp_ImageName, (int)L\"*\\\\2345chrome.exe*\")\r\n\t            || m_strcmp(lp_ImageName, (int)L\"*\\\\firefox.exe*\")\r\n\t            || m_strcmp(lp_ImageName, (int)L\"*\\\\Maxthon.exe*\")\r\n\t            || m_strcmp(lp_ImageName, (int)L\"*\\\\rccb.exe*\")\r\n\t            || m_strcmp(lp_ImageName, (int)L\"*\\\\SogouExplorer.exe*\")\r\n\t            || m_strcmp(lp_ImageName, (int)L\"*\\\\TaoBrowser.exe*\")\r\n\t            || m_strcmp(lp_ImageName, (int)L\"*\\\\TheWorld.exe*\")\r\n\t            || m_strcmp(lp_ImageName, (int)L\"*\\\\UCBrowser.exe*\")\r\n\t            || m_strcmp(lp_ImageName, (int)L\"*\\\\YYExplorer.exe*\") )\r\n\r\n - 针对QQ浏览器(`QQBrowser.exe`)，使用`FindWindoW`，`FindWindowExW`来获取浏览器地址栏，向其写入参数。\r\n\r\n\t\t\t  do\r\n\t\t\t  {\r\n\t\t\t    v2 = FindWindowW(L\"QQBrowserMainFrame\", 0);\r\n\t\t\t    v3 = FindWindowExW(v2, 0, L\"QQBrowserRebar\", 0);\r\n\t\t\t    v4 = FindWindowExW(v3, 0, L\"QQBrowserAddressBar\", 0);\r\n\t\t\t    v5 = FindWindowExW(v4, 0, L\"QQBrowserCoreRichEdit\", 0);\r\n\t\t\t  }\r\n\t\t\t  while ( !v5 );\r\n\t\t\t  v6 = 0;\r\n\t\t\t  do\r\n\t\t\t  {\r\n\t\t\t    v7 = v13[v6];\r\n\t\t\t    d_url[v6] = v7;\r\n\t\t\t    ++v6;\r\n\t\t\t  }\r\n\t\t\t  while ( v7 );\r\n\t\t\t  SendMessageW(v5, 0xCu, 0, (LPARAM)d_url);\r\n\t\t\t  SendMessageW(v5, 0x100u, 0xDu, 1);\r\n\t\t\t  SendMessageW(v5, 0x101u, 0xDu, 1);\r\n\t\t\t  Sleep(0x3E8u);\r\n\t\t\t  SendMessageW(v5, 0xCu, 0, (LPARAM)d_url);\r\n\t\t\t  SendMessageW(v5, 0x100u, 0xDu, 1);\r\n\t\t\t  return SendMessageW(v5, 0x101u, 0xDu, 1);\r\n\r\n简单说一下`Dump`出来的文件，对文件头进行修复的方法。由于我们`Dump`的是内存中的文件，该文件的虚拟地址和虚拟大小，会被认为是原始地址和原始大小，而真正的虚拟地址和大小会不正常。导致IDA加载时，出现地址错乱等一系列的问题，这里，我们使用`PE`头修改工具，将虚拟地址和虚拟大小改为与原始地址和原始大小一样就可以正常加载。因为IDA正常识别出来了所使用的函数，上面获取的函数就没什么用了。\r\n\r\n##总结\r\n\r\n样本通过`PE`文件释放驱动程序，并进行安装。驱动程序创建进程回调函数和映像加载回调函数。当发现浏览器进程被创建时，在映像加载之后，未执行之前，在映像内创建新的`Section`，写入修改浏览器主页的代码。对这个样本的分析持续了一周多的时间，但并未分析透彻，只是完成了最初的疑问，也对驱动调试有了新的认识。\r\n\r\n<div align=right>(如有问题，请联系：l0g1n@qq.com)</div>","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}